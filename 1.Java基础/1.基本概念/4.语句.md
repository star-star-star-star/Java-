# 语句

|语句|作用|句法|
|-|-|-|
|表达式|副作用|`var = expr;` `expr++;` `method( );` `new Type( );`|
|复合语句|语句组|`{ statements }`|
|空语句|无作用|`;`|
|标注|为语句命名|`label: statement`|
|变量|声明变量|`[final] type name [=value][,name[=value]]...;`|
|if|条件判断|`if (expr) statement [else statement]`|
|switch|条件判断|`switch (expr) {[case expr : statements] ... [default : statements]}`|
|while|循环|`while (expr) statement`|
|do|循环|`do statement while (expr);`|
|for|简单循环|`for (init ; test ; increment) statement`|
|遍历|迭代集合|`for(variable  : iterable) statement`|
|break|退出块|`break [label];`|
|continue|重新开始循环|`continue [label];`|
|return|结束方法|`return [expr];`|
|synchronized|临界区|`synchronized (expr) {statements}`|
|throw|抛出异常|`throw expr;`|
|try|处理异常|`try {statements} [catch (type name) {statements}]...[finally{statements}]`|
|assert|验证不变式|`assert invariant[ :error];`|

# 表达式语句

合法的表达式语句有赋值、递增和递减、方法调用以及对象创建。

# 复合语句

复合语句是一些放在花括号 `{ }` 里的语句，语句的数量和类型不限，可以使用语句的地方都可以使用复合语句。

# 空语句

空语句使用一个分号 `;` 表示。空语句什么也不做。

# 标注语句

标注语句就是有名称的语句。命名方法为：在语句前加上一个标识符和一个冒号 `:` 。break 和 continue 语句会用到标注。

# 局部变量声明语句

局部变量经常直接称为变量，是值存储位置的符号名称，在方法和复合语句中定义。所有的变量在使用前必须先声明，声明变量的方法是使用声明语句。Java是静态类型的语言，声明变量时要指定变量的类型，而且只有这种类型的值才能存储在这个变量中。

变量声明语句最简单的形式只需要指定变量类型和名称。

声明变量时还可以包含一个初始化表达式，用于指定变量的初始值。

Java编译器不允许使用未初始化的局部变量，因此，方便起见，通常会在一个语句中同时声明和初始化变量。初始化表达式不必是编译器能计算得到的结果的字面量或常量表达式，也可以是程序运行时能计算出结果的任意复杂表达式。

一个变量声明语句可以声明和初始化多个变量，但是这些变量必须是同一个类型。变量名称和可选的初始化表达式使用逗号 `,` 分隔。

变量声明语句可以以 `final` 关键字开头，这个修饰符表明，为变量指定初始值后，其值不能改变。

在Java代码的任何地方都能使用变量声明语句，而不局限于只能在方法和代码块的开头使用。

局部变量只能在其定义所在的方法和代码块中使用，这叫做变量的作用域或词法作用域。

# if...else...语句

if语句是基本的控制语句，允许Java作出判断，根据条件决定执行哪些语句。if语句有关联的表达式和语句，如果表达式的计算结果为true，解释器会执行关联的语句；如果表达式的计算结果为false，解释器会跳过关联的语句。

需要注意的是，Java允许在关联的表达式中使用包装类型Boolean代替基本类型boolean，此时，包装对象会自动拆包。

if语句可以包含一个可选的else关键字，并在后面跟着另一个语句。在这种形式中，如果表达式的计算结果为true，会执行第一个语句，否则执行第二个语句。

嵌套使用if/else语句时要注意，必须确保else子句和正确的if语句匹配。else子句会和最近的if语句关联。

if/else语句适用于测试一个条件，并在两个语句或代码块中选择一个执行。else/if子句适用于需要在多个代码块中选择。

# switch语句

if语句在程序的执行过程中创建一个分支，可以使用多个if语句创建多个分支，但这么做并不总是最好的方法，尤其是所有分支都判断同一个变量的值时，在多个if语句中重复检查这个变量的值效率不高。此时便可以使用switch语句。

switch语句以一个表达式开始，这个表达式的返回值是int、short、char、byte（或者这四个类型的包装类型）、String或枚举类型。这个表达式后面跟着一段放在花括号里面的代码，这段代码中有多个入口点，对应于表达式各个可能的返回值。

switch语句的各入口点有两种形式：一种使用关键字case标注，后面跟着一个整数（也可以是其他类型的数据）和一个冒号 `:` ；另一种使用特殊的关键字default标注，后面跟着一个冒号 `:` 。解释器执行switch语句时，先计算括号中表达式的值，然后查找有没有匹配这个值的case标注。如果有，解释器就从这个case标注后的代码块中的第一个语句开始执行；如果没有，解释器从特殊的default标注后的代码块中第一个语句开始执行；如果没有default标注，解释器会跳过整个switch语句主体。

每一个case子句的末尾都有break关键字，它的作用是让解释器推出switch语句的主体。switch语句中的case子句只用来指定需要执行的代码起始点，各case子句后的代码块不是相互独立的，没有任何隐式的结束点。因此，必须使用break或相关的语句明确指定各case子句在哪里结束。如果没有break语句，switch语句会从匹配的case标注后第一个语句开始执行，一直到代码块结束为止。极少数的情况下会这样编写代码。一般情况下使用break语句，不过使用return和throw语句也可以。

switch语句可以使用多个子case子句标注同一个希望执行的语句。例如：

```Java
boolean Function(char chr){
	switch(chr){
		case 'a' :
		case 'A' : return true;
		default : return false;
	}
}
```

switch语句和case语句标注有些重要的限制。首先，switch语句关联的表达式必须是适当的类型，可以是byte、char、short、int（以及这四种类型的包装类型）、枚举类型或String类型，不支持浮点数类型和布尔类型，也不能用long类型。其次，各case标注关联的值必须是编译器能计算的常量或常量表达式，不能包含运行时表达式（例如变量或方法调用）。再次，case标注的值必须在switch表达式返回值对应数据类型的取值范围内。最后，不能有两个或多个case标注使用同一个值，而且default标注不能超过一个。

# while语句

while语句先计算expression的值。计算结果必须是布尔值。如果计算结果为false，解释器跳过循环中的statement，执行程序中的下一个语句。如果计算结果为true，解释器执行组成循环主体的statement，然后再次计算expression的值。如果计算结果为false，解释器执行程序中的下一个语句；否则，再次执行statement。之要expression的计算结果为true，就会一直循环下去，while语句结束后（即expression的计算结果为false）解释器才会执行下一个语句。

# do...while语句

do循环和while循环很像，不过do循环中，循环表达式不在循环开头而在循环末尾。也就是说，循环主体至少会执行一次。

需要注意的是，do循环和更普通的while循环有几个不同点。首先，do循环既需要使用关键字do标记循环的开头，也要使用关键字while标记循环的结尾，以及引入循环条件。其次，与while循环不同的是，do循环的结尾要使用分号。这是因为do循环以循环条件结尾，而不是标记循环主体结束的花括号。

# for语句

for语句利用了一般循环的执行模式。大多数循环都有一个计数器，或者某种形式的状态变量，在循环开始前初始化，然后测试这个变量的值，决定是否执行循环主体，再次计算表达式的值之前，在循环主体末尾递增或者以某种方式更新这个变量的值。初始化、测试和更新，这三步是循环变量的重要操作，for语句把这三步作为循环句法的明确组成部分。

for语句的结构如下：

```Java
for(initialize ; test ; update){
	statement
}
```

for循环还支持一种句法，可以让循环更便于使用。很多循环都只在循环内部使用循环变量，因此for循环允许initialize是一个完整的变量声明表达式，这样循环变量的作用域是循环主体，在循环外部不可见。而且，for循环的句法不限制只能使用一个变量，initialize和update表达式都能使用逗号分隔多个初始化和更新表达式。

在for循环中，initialize、test和update表达式都是可选的，只有分隔这些表达式的分号 `;` 是必须的。如果没有test表达式，其值假定为true，因此可以使用 `for(;;)` 编写一个无限循环。

# foreach语句

Java的for循环可以很好地处理基本类型，但是处理对象集合时没什么用，而且笨拙。不过，有种叫做“遍历循环”（foreach loop）的句法可以处理需要循环的对象集合。

遍历循环以关键字 `for` 开头，后面跟着一对括号 `( )` ，括号里面是变量声明（不进行初始化）、冒号和表达式，括号后面是组成循环主体的语句或语句块。

需要注意的是，遍历循环虽然叫做遍历循环，但是不使用 foreach 关键字。冒号一般读作“……中”。

遍历和while、for或do循环不同，因为它隐藏了循环计数器或Iterator对象。这种想法很好，但是有些算法不能使用遍历循环自然地表达出来。例如使用遍历循环迭代数组时无法获取当前元素的索引，同样，使用遍历迭代集合也无法获取列举集合元素的Iterator对象。

还有一些事情是遍历循环做不到的：
+ 反向迭代数组或List对象中的元素。
+ 使用同一个循环计数器获取两个不同数组同一索引位的元素。
+ 通过调用List的get( )方法遍历元素，而不是使用它的迭代器。

# break语句

break语句让Java解释器立即跳出所在的语句块。break语句最常写成关键字break后面跟一个分号 `break;` 。

这种形式让Java解释器立即退出所在的最内层while、do、for或switch语句。

break语句后面也可以跟着标注语句的名称。此时，break语句让Java解释器立即退出指定的语句块。退出的语句块可以是任何类型，不只局限于循环或switch语句。

# continue语句

continue语句的作用是中止本次循环，开始下一次循环。continue语句，无论是否有标注，只能在while、do或for循环中使用。

如果continue语句没有指定标注，continue语句让最内层循环开始下一次循环；如果指定了标注，continue语句让对应的循环开始下一次循环。

在while、do和for循环中，continue语句开始下一次循环的方式略有不同：
+ 在while循环中，Java解释器直接返回循环开头，再次测试循环条件，如果计算结果为true，则再次执行循环主体。
+ 在do循环中，Java解释器跳到循环末尾，测试循环条件，决定是否要执行下一次循环。
+ 在for循环中，Java解释器跳到循环开头，先计算update表达式，然后计算test表达式，以此决定是否继续循环。

# return语句

return语句告诉Java解释器中止执行当前方法。如果声明方法时指明了有返回值，return语句后面必须跟着一个表达式，这个表达式的返回值就是这个方法的返回值。

有些方法声明时使用了void，指明不返回任何值。Java解释器运行这种方法时，会依次执行其中的语句，直到方法结束为止。执行完最后一个语句时，解释器隐式返回。然而，有时候没有返回值的方法要在到达最后一个语句之前显式返回。此时便可以使用后面没有任何表达式的return语句。

# synchronized语句

处理多线程时，经常必须避免多个线程同时修改同一个对象，以防对象的状态有冲突。Java提供的synchronized语句可以帮助程序员，避免发生冲突。

synchronized语句的句法为：

```
synchronized ( expression ) {
	statements
}
```

expression代表一个对象或者一个数组。statements是能导致破坏的代码块（临界段），必须放在花括号里。

在执行语句块之前，Java解释器先为expression所定义的对象或数组获取一个排他锁（exclusive lock），直到语句块执行完毕后再释放。之要某个线程拥有对象的排他锁，其他线程就不能再获取这个锁。

在Java中，synchronized关键字还可以作为方法的修饰符。应用于方法时，synchronized关键字指明整个方法都被锁定。如果synchronized关键字应用于类方法（静态方法），执行方法前，Java解释器会先为这个类获取一个排他锁。如果synchronized关键字应用于实例方法，Java解释器为类的实例获取一个排他锁。

# throw语句

异常是一种信号，表明发生了某种异常状况或错误。抛出异常时表明有未预料的状况发生。捕获异常的目的是处理异常，使用必要的操作修复。在Java中，throw语句用于抛出异常。

throw语句的句法为：

```
throw expression;
```

expression必须是一个异常对象，说明发生了什么异常或错误。

Java解释器执行throw语句时，会立即停止常规的程序执行，开始寻找能捕获或处理异常的异常处理程序，异常处理程序使用try/catch/finally语句编写。Java解释器先在当前代码块中查找异常处理程序，如果有，解释器会退出这个代码块，开始执行异常处理代码。异常处理程序执行完毕后，解释器会继续处理程序后的语句。

如果当前代码块中没有适当的异常处理程序，解释器会在外层代码块中寻找，直到找到为止。如果方法中没有能处理throw语句抛出的异常的处理程序，解释器会停止运行当前方法，返回调用这个方法的地方，开始在调用方法的代码块中寻找异常处理程序。Java通过这种方式，通过方法的词法结构不断向上冒泡，顺着解释器的调用堆栈一直向上寻找。如果一直没有捕获异常，就会冒泡到程序的main()方法。如果在main()方法中也没有处理异常，Java解释器会打印一个错误消息，还会打印一个堆栈跟踪，指明这个异常在哪里发生，然后退出。

# try...catch...finally语句

Java有两种稍微不同的异常处理机制。经典形式是使用try/catch/finally语句。这个语句的try子句是可能抛出异常的代码块。try代码块后面是零个或多个catch子句，每个子句用于处理特定类型的异常，而且能够处理多个不同类型的异常。如果catch块要处理多个异常，使用 `|` 分隔各个不同的异常。catch子句后面是一个可选的finally块，包含清理代码，不管try块中发生了什么，始终会执行finally块。

虽然catch和finally子句都是可选的，但是每个try块必须有这两个子句中的一个。try、catch和finally块都放在花括号中。花括号是句法必须的一部分，即使子句只包含一个语句也不能省略。

try子句的作用很简单，本身没有什么用，异常处理和清理操作在catch和finally子句中进行。

try块后面可以跟着零个或多个catch子句，指定处理各种异常的代码。每个catch子句只有一个参数（可以使用特殊的 `|` 句法指明catch块能够处理多种异常类型，例如 `catch ( AnotherException | YetAnotherException e1)` ），指定这个子句能处理的异常类型，以及一个名称，用来引用当前处理的异常对象。catch块能处理的类型必须是Throwable的子类。

有异常抛出时，Java解释器会寻找一个catch子句，它的参数要和异常对象的类型相同，或者是这个类型的子类。解释器会调用它找到的第一个这种catch子句。catch块中的代码应该执行处理异常状况所需的任何操作。

不是所有可能抛出的异常都要有一个catch子句处理，有些情况下，正确的处理方式是让异常向上冒泡，由调用方法捕获。还有些情况，例如表示程序错误的 NullPointerException 异常，正确的处理方式或许是完全不捕获，随它冒泡，让Java解释器退出，打印堆栈跟踪和错误信息。

finally子句放在try子句后面，一般用来执行清理操作（例如关闭文件和网络连接）。finally子句很有用，因为不管try块中的代码以何种方式结束执行，只要有代码执行，finally子句中的代码就会执行。事实上只有一种方法能够让try子句退出而不执行finally子句——调用 System.exit() 方法，让Java解释器停止运行。

正常情况下，执行到try块末尾后继续执行finally块，做必要的清理工作。如果因为return、continue或break语句而离开try块，会先执行finally块，然后再转向新的目标代码。

如果try块抛出了异常，而且有处理该异常的catch块，那么先执行catch块，然后再执行finally块。如果本地没有能够处理该异常的catch块，先执行finally块，然后再向上冒泡到能处理该异常最近的catch子句。

如果finally块使用return、continue、break或throw语句，或者调用的方法抛出了异常，从而转移了控制权，那么待转移的控制权中止，改为执行新的控制权转移。

try和finally子句可以放在一起使用，不处理异常，也没有catch子句。此时，finally块只是负责清理代码，不管try子句中有没有break、continue或return语句，都会执行。

# TWR语句

catch和finally子句可以清理或关闭不再需要使用的资源，但是有时候编写的代码可能会出错，此时就可以使用处理资源的try语句。

Java提供了一种很有用的机制，能自动关闭需要清理的资源——处理资源的try语句（try-with-resources, TWR）。这种新型try语句的参数都是需要清理的对象（严格来说，这些对象必须实现 AutoCloseable 接口）。这些对象的作用域在try块中，不管try块以何种方式退出，都会自动清理，开发者无需编写任何catch或finally块，Java编译器会自动插入正确的清理代码。

所有处理资源的新代码都应该使用TWR形式编写，因为这种形式比自己动手编写catch块更少出错，而且不会遇到麻烦的技术问题。

# assert语句

assert语句用来验证Java代码的设计假想。断言（assertion）由assert关键字和布尔表达式组成，程序员认为布尔表达式的结果始终应该为true。默认情况下断言未启用，assert语句什么作用也没有。不过，可以使用启用断言，作为一种调试工具。启用后，assert语句会计算表达式。如果表达式的计算结果确是true，assert语句什么也不做；如果计算结果是false，断言失败，assert语句抛出 java.lang.AssertionError 异常。

需要注意的是，在JDK库之外，极少使用assert语句。用它测试大多数应用都不灵便，一般的开发者很少使用，不过有时用来现场调试复杂的多线程应用。

assert语句可以包含可选的第二个表达式，使用冒号和第一个表达式分开。如果启用了断言，而且第一个表达式的计算结果为false，那么第二个表达式的值会作为错误代码或错误消息传给 AssertionError() 构造方法。

为了有效使用断言，必须注意几处细节。首先，要记住，一般情况下程序没有启用断言，只有少数情况才会启用。这意味着，编写断言表达式时要小心，不能有副作用。

绝对不要再自己编写的代码中抛出 AssertionError 异常，如果这么做，可能会在Java平台未来的版本中得到意料之外的结果。

如果抛出了 AssertionError 异常，表明程序员的假想之一没有实现。这意味着，在设计的使用范围之外使用了代码，无法正常运行。简单来说，没有看似合理的方式能从 AssertionError 异常中恢复，因此不要尝试捕获这个异常（除非在顶层简单捕获，以对用户更友好的方式显示错误）。

为了效率，不应该在每次执行代码时都测试断言，因为assert语句认为假想始终为真。因此，默认情况下禁用了断言，assert语句没有作用。不过，断言代码还是会编译到类文件中，所以需要诊断或调试时可以启用断言。断言可以全局启用，也可以把命令行参数传给Java解释器，有选择性地启用。

如果想为系统类之外的所有类启用断言，使用 `-ea` 参数。如果想为系统类启用断言，使用 `-esa` 参数。如果想为某个具体的类启用断言，使用 `-ea` 参数，后面跟一个冒号和类名。如果想为包中所有的类和子包启用断言，在 `-ea` 参数后面加上冒号、包名和三个点号 `...` 。使用 `-da` 参数，通过相同的方式可以禁用断言。最后，类加载时可以控制是否启用断言。
