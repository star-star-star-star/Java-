# 方法的概念

方法是有名称的Java语句序列，可以被其他Java代码调用。调用方法时，可以传入零个或多个值，这些值叫参数。方法执行一些计算，还可以返回一个值。

# 定义方法

方法的签名指定下述内容：
+ 方法的名称；
+ 方法所用参数的数量、顺序、类型和名称；
+ 方法的返回值类型；
+ 方法能抛出的已检异常（签名还能列出未检异常，不过不是必须的）；
+ 提供方法额外信息的多个方法修饰符。

方法签名定义了调用方法之前需要知道的一切信息，是方法的规范，而且定义了方法的API。

方法都以方法签名开头，方法签名的格式如下：

```
modifiers type name ( paramlist ) [ throws exceptions ]
```

modifiers是零个或多个特殊的修饰符关键字，之间使用空格分开。type指明方法返回值的类型。如果方法没有返回值，type必须是void。如果声明方法时指定了返回类型，就必须包含一个return语句，返回一个符合（或者能转换为）所声明类型的值。方法的修饰符和返回值类型后面是name，即方法名。方法名和变量名一样，也是Java标识符。和所有Java标识符一样，方法名可以包含Unicode字符集能表示的任何语言的字母。

签名（方法规范）后面是方法主体（方法的实现），即放在花括号里的Java语句序列。抽象方法没有实现部分，方法主体使用一个分号表示。

方法签名中可能包含类型变量声明，这种方法叫泛型方法（generic method）。

构造方法是一段类似方法的代码，用于初始化新建的对象，不过签名中没有type部分。

定义多个同名方法是合法的，往往也很有用，之要各方法的参数列表不同就行。定义多个同名方法叫方法重载（method overloading）。

Java没有匿名方法，不过，Java 8引入了lambda表达式，作用类似于匿名方法，但是Java运行时会自动把lambda表达式转换成适当的具名方法。

定义方法时，方法名后面一定是方法的形参列表（parameters list），而且必须放在花括号里。形参列表定义零个或多个传入方法的实参（argument）。如果有形参的话，每个形参都包含类型和名称，（如果有多个形参）形参之间使用逗号分隔。调用方法时，传入的实参值必须和该方法签名中定义的形参数量、类型和顺序匹配。传入的值不一定要和签名中指定的类型一样，但是必须能不经校正转换为对应的类型。

Java允许程序员定义和调用参数数量不定的方法，使用的句法叫变长参数（varargs）。

方法签名的最后一部分是throws子句，列出方法能抛出的已检异常（checked exception）。已检异常是一些列异常类，必须在能抛出它们的方法中使用throws子句列出。如果方法使用throw语句抛出一个已检异常，或者调用的其他方法抛出一个没有捕获或处理的已检异常，声明这个方法时就必须指明能抛出这个异常。如果方法能抛出一个或多个已检异常，要在参数列表后面使用throws关键字指明能抛出的异常类。如果方法不会抛出异常，无需使用throws关键字。如果方法抛出的异常类型不止一个，要使用逗号分隔异常类的名称。

# 方法的修饰符

方法修饰符包含零个或多个修饰符关键字，下面列出了允许使用的修饰符及其意义。

+ abstract：使用abstract修饰的方法没有实现主体。组成普通方法主体的花括号和Java语句使用一个分号代替。如果类中有使用abstract修饰的方法，类本身也必须使用abstract声明。这种类不完整，不能实例化。
+ final：使用final修饰的方法不能被子类覆盖或隐藏，能获得普通方法无法得到的编译器优化。所有使用private修饰的方法都隐式添加了final修饰符。使用final声明的任何类，其中的所有方法也都隐式添加final修饰符。
+ native：native修饰符表明方法的实现使用某种“本地”语言编写，并且开放给Java程序使用。native修饰的方法和abstract修饰的方法一样，没有主体：花括号使用一个分号代替。native修饰的方法和所在平台无关，如何把实现和方法声明所在的Java类链接起来，取决于Java虚拟机的实现方式。
+ public、protected、private：这些访问修饰符指定方法是否能在定义它的类之外使用，或者能在何处使用。
+ static：使用static声明的方法是类方法，关联在类自己身上，而不是类的实例身上。
+ strictfp：fp的意思是“浮点”（floating point）。一般情况先，Java会利用运行时所在平台的浮点硬件提供的可用扩展精度。添加这个关键字后，运行strictfp修饰的方法时，Java会严格遵守标准，而且就算结果不精确，也只使用32位或64位浮点数格式进行浮点运算。
+ synchronized：synchronized修饰符的作用是实现线程安全的方法。线程调用synchronized修饰的方法之前，必须先为方法所在的类（针对static修饰的方法）或对应的类实例（针对没有使用static修饰的方法）获取一个锁，避免两个线程同时执行该方法。需要注意的是，synchronized修饰符是实现的细节（因为方法可以通过其他方式实现线程安全），不是方法规范或API的正式组成部分。好的文档应该明确说明方法是否线程安全；当编写多线程程序时，不应通过方法中是否有synchronized关键字来判断方法是否线程安全。

# 方法异常

Java的异常处理机制会区分两种不同的异常类型：已检异常和未检异常。

已检异常和未检异常之间的区别在于异常在什么情况下抛出。已检异常在明确的特定情况下抛出，经常是应用能部分或完全恢复的情况。然而，在Java环境中有些失败是无法预料的，这些失败可能是由运行时条件或滥用库代码导致的，这些是未检异常。基本上任何方法在任何时候都可能抛出未检异常。从未检异常中恢复虽说不是不可能，但往往很难，因为完全不可预知。

若想区分已检异常和未检异常，记住两点：异常是Throwable对象，而且异常主要分为两类，通过Error和Exception子类标识。只要异常对象是Error类，就是未检异常。Exception类还有一个子类RuntimeException，RuntimeException类的所有子类都属于未检异常。除此之外，都是已检异常。

Java为已检异常和未检异常制定了不同的规则。如果定义的方法会抛出已检异常，就必须在方法签名的throws子句中声明这个异常。Java解释器会检查方法签名，确保的确声明了；如果没有声明，会导致编译出错。

就算自己从不抛出已检异常，有时也必须使用throws子句声明已检异常。如果方法中调用了会抛出已检异常的方法，要么加入异常处理代码处理这个异常，要么使用throws子句声明这个方法也能抛出这个异常。

# 变长参数列表

方法可以声明为接受数量不定的参数，调用时也可以传入数量不定的参数。这种方法一般叫做变长参数方法。

变长参数列表的声明方式为，在方法最后一个参数的类型后面加上省略号 `...` ，指明最后一个参数可以重复零次或多次。

变长参数方法纯粹由编译器处理，把数量不定的参数转换为一个数组。

把变长参数方法的签名转换为真正的签名，只需要把 `...` 换成 `[ ]` 。记住，参数列表中只能有一个省略号，而且只能出现在最后一个参数中。

因为边长参数方法被编译成接受数组参数的方法，所以在编译对这类方法的调用得到的代码中，包含创建和初始化这个数组的代码。

其实，如果参数的方法已经存储在数组中，完全可以直接把数组传给变长参数方法，而不用把数组中的元素取出来一个一个传入。`...` 参数可以看成一个数组。不过。反过来就不行了：只有使用省略号声明为变长参数方法，才能使用变长参数方法调用的句法。

