# 数组的概念

数组是一种特殊的对象，保存零个或多个基本类型或引用类型的值。这些值是数组的元素，是通过所在位置或索引引用的无名变量。数组的类型通过元素的类型表示，数组中的所有元素必须都属于这个类型。

数组元素的编号从零开始，有效的索引范围是零到元素数量减一。数组的长度在创建时指定，从此就不能改变。

数组中元素的类型可以是任何有效的Java类型，包括数组类型。也就是所，Java支持由数组组成的数组，实现多维数组。但是Java不支持其他语言中的矩阵式多维数组。

# 数组的类型

数组的类型和类一样，也是引用类型。数组的实例和类的实例一样，也是对象。和类不同的是，数组的类型不用定义，只需要在元素类型后面加上一对中括号即可。

数组的长度不是数组类型的一部分。数组类型不是类，但数组实例是对象。这意味着，数组从 java.lang.Object 类继承了方法。数组实现了 Cloneable 接口，而且覆盖了 clone() 方法，确保数组始终能被复制，而且 clone() 方法从不抛出 CloneNotSupportedException 异常。数组还实现了 Serializable 接口，所以只要数组中元素的类型能被序列化，数组就能被序列化。而且，所有数组都有一个名为 length 的字段，这个字段的修饰符是 public final int ，表示数组中元素的数量。

因为数组扩展自 Object 类，而且实现了 Cloneable 和 Serializable 接口，所以任何数组类型都能放大转换成这三种类型中的任意一种。而且，特定的数组类型还能放大转换成其他数组类型。如果数组中的元素类型是引用类型 T，而且 T 能指定给类型 S，那么数组类型 `T[ ]` 就能指定给数组类型 `S[ ]` 。但是需要注意的是，基本类型的数组不能放大转换。因为数组类型可以放大转换成另一种数组类型，所以编译时和运行时数组的类型并不总是一样。这种放大转换叫做“数组协变”（array covariance）。

把引用类型的值存储在数组元素中之前，编译器通常必须插入运行时检查，确保运行时这个值的类型和数组元素的类型匹配。如果运行时检查失败，会抛出 ArrayStoreException 异常。

数组的声明句法与C语言兼容，下面三行代码声明的字段属于同一种数组类型。

```Java
int [][] arr1;    //推荐使用的Java句法
int arr2[][];    //C语言的句法
int[] arr3[];    //混用句法，十分令人困惑
```

这种兼容句法及其少见，不要使用。

# 创建以及初始化数组

在Java中，使用 new 关键字创建数组，就像创建对象一样。数组类型没有构造方法，但创建数组时要指定长度，在中括号里使用非负整数指定所需的数组大小。使用这种句法创建的数组，每个元素都会自动初始化，初始值和类中的字段默认值相同。

创建数组的表达式也能用来创建和初始化多维数组。

若想在一个表达式中创建数组并初始化其中的元素，不要指定数组的长度，在方括号 `[ ]` 后面跟着一对花括号 `{ }` ，在花括号里写入一些逗号分隔的表达式。当然了，每个表达式的返回值类型必须能指定给数组元素的类型。创建的数组长度和表达式的数量相等。需要注意的是，这种句法无需把数组赋值给变量就能创建、初始化和使用数组。某种意义上，这种创建数组的表达式相当于匿名数组的字面量。

如果数组初始化程序是变量声明的一部分，可以省略new关键字和元素类型，在花括号里列出所需的元素。

数组字面量在程序运行时进行创建和初始化，而不是在程序编译时进行。

Java在运行时初始化数组有个重要的推论：数组初始化程序中的表达式可能会在运行时计算，而且不一定非要使用编译时常量。

# 使用数组

## 访问数组中的元素

数组中的元素是变量。如果元素出现在表达式中，其计算结果是这个元素中保存的值。如果元素出现在赋值运算符的左边，会把一个新值保存到这个元素中。不过，元素和普通的变量不同，它没有名字，只有编号。数组中的元素使用方括号访问。

数组的索引表达式必须是 int 类型，或能放大转换成 int 的类型：byte、short，甚至是char。数组的length字段是int类型，所以数组中的元素数量不能超过 Integer.MAX_VALUE。如果使用long类型的表达式索引数组，即便运行时表达式的返回值在int类型的取值范围内，也会导致编译出错。

## 数组的边界

使用数组时常见的错误是索引太小（负数）或太大（大于或等于数组的长度）。在C或C++等语言中，如果访问起始索引之前或结尾索引之后的元素，会导致无法预料的行为，而且在不同的调用和不同的平台中有所不同。这种问题不一定会被捕获，如果没捕获，可能过一段时间才会发现。因为在Java中容易编写错误的索引代码，所以每次访问数组都会做检查，确保得到能预料的结果。如果数组的索引太大或太小，Java会立即抛出 `ArrayIndexOutOfBoundsException` 异常。

## 迭代数组

为了在数组上执行某种操作，经常要编写循环，迭代数组中的每个元素。这种操作通常使用for循环完成（如果不要求获取索引的话，也可以使用foreach）。

## 复制数组

所有数组类型都实现了 Cloneable 接口，任何数组都能调用 clone() 方法复制自己。需要注意的是，返回值必须校正成适当的数组类型。不过，在数组上调用 clone() 方法不会抛出 CloneNotSupportedException 异常。但是，Clone（）方法执行的是浅复制。如果数组的元素是引用类型，那么只复制引用，而不会复制引用的对象。因为这种复制是浅复制，所以任何数组都能被复制，就算元素类型没有实现 Cloneable 接口也行。

不过，有时只想把一个现有数组中的元素复制到另一个现有数组中。 `System.arraycopy()` 方法的目的就是高效完成这种操作。可以假定Java虚拟机会在底层硬件中使用高速块复制操作执行这个方法。arraycopy() 方法的作用简单明了，但是有五个参数：源数组，源数组中起始元素的索引，目标数组，目标索引，要复制的元素个数。当然，这个方法就算重叠复制同一个数组也没有任何问题。

## 实用方法

 `java.util.Arrays` 类中包含很多处理数组的静态实用方法。这些方法大多都高度重载，有针对各种基本类型数组的版本，也有针对对象数组的版本。例如可以使用 `sort()` 方法排序数组、使用 `binarySearch()` 方法搜索数组、使用 `equals()` 方法比较两个数组的内容、使用 `Arrays.toString()` 方法将数组的内容转换成一个字符串。

Arrays类中还包含能处理多维数组的方法，例如 `deepEquals()` `deepHashCode()` `deepToString()` 。

# 多维数组

多维数组中的每对方括号都表示一个维度，例如 `int[][] arr1;` 是一个二维数组。若想要访问多维数组中的某个元素值，必须指定该数组的所有维度。

创建多维数组要使用 new 关键字，而且要指定每个维度中数组的大小。例如 `int[][] arr1 = new int[20][20];` 。需要注意的是，在某些语言中，会把这样的数组创建成包含400个int值的数组，但是Java不会这样处理，这行代码会做三件事：
1. 声明一个名为 arr1 的变量，保存一个由 `int[]` 类型数组组成的数组。
2. 创建一个有20个元素的数组，保存20个 `int[]` 类型的数组。
3. 再创建20个数组，每个由20个int类型的元素组成。然后把这20个新数组指定为前一步创建的数组的元素。这20个新数组中的每个int类型元素的默认值都是0。
也就是说，这行代码等价于：

```Java
int[][] arr1 = new int[20][];
for(int i = 0; i < 20; i++){
	arr1[i] = new int[20];
}
```

不过，new关键字会自动执行这些额外的初始化操作。超过两个维度的数组也是一样的。

需要注意的是，使用new关键字创建多维数组时，无需指定所有维度的大小，只要为最左边的几个维度指定大小就行。例如：

```Java
int[][] arr1 = new int[10][];
int[][][] arr2 = new int[10][][];
int[][][] arr3 = new int[10][10][];

//之要最左边的几个维度指定大小即可
```

如果不想声明变量就使用多维数组，可以使用匿名初始化程序句法。

使用new关键字创建多维数组时，往往最好只使用矩形数组，即每个维度的数组大小相同。
