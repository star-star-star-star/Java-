# 引用类型和基本类型的区别

引用类型与基本类型有着本质上的区别：
+ 八种基本类型由Java语言定义，程序员不能定义新的基本类型。引用类型由用户定义，因此有无限多个。
+ 基本类型表示单个值。引用类型是聚合类型（aggregate type），可以保存零个或多个基本值或对象。
+ 基本类型需要一个~八个字节的内存空间。把基本值存储到变量中，或者传入方法时，计算机会复制表示这个值的字节。而对象基本上需要更多的内存。创建对象时会在堆（heap）中动态分配内存，存储这个对象；如果不再需要使用这个对象了，存储它的内存就会被自动垃圾回收。

需要注意的是，把对象赋值给变量或传入方法时，不会复制表示这个对象的内存，而是把这个内存的引用存储在变量中或传入方法。

在Java中，引用完全不透明，引用的表示方式由Java运行时的实现细节决定。如果你是C程序员的话，完全可以把引用看作指针或内存地址，不过要记住，Java程序无法使用任何方式处理引用。

和C/C++中的指针不同的是，引用不能转换成整数，也不能把整数转换成引用，而且不能递增或递减。C/C++程序员还要注意的是，Java不支持求地址运算符 `&` ，也不支持解除引用运算符 `*` 和 `->` 。

# 处理对象和引用副本

对于一个基本类型：

```Java
int a = 100;
int b = a;
```

执行这两行代码之后，变量 b 中保存了变量 a 中所存值的一个副本。在Java虚拟机内部，这个32位整数100有两个独立的副本，修改变量 a 的值后，对变量 b 的值不会有任何影响；修改变量 b 的值后，对变量 a 的值不会有任何影响。

但是，对于一个引用类型，指向某个引用类型的所有变量共享该引用类型，也就是说，这个引用类型在堆中只有一个副本，修改任何一个指向该引用的变量，其余指向该引用的变量所获取的副本内容都会改变。当然了，数组也会如此，因为数组也是一种对象。

把基本类型和引用类型的参数传入方法时也有类似的区别。

总之，对于基本类型，变量得到的是私有值；对于引用类型，变量得到的是共享值。

# 对两个对象进行比较

对于相等运算符 `==` 而言，比较的是两个基本值是否相等以及两个引用是否指向同一个对象，而不是测试两个对象的内容是否相等。

对于引用类型来说，有两种相等：引用相等和对象相等。一定要把这两种相等区分开。其中一种方式是，使用“相同”（identical）表示引用相等，使用“相等”（equal）表示对象的内容一样。若想测试两个对象是否相等，可以在一个对象上调用 `equals()` 方法，然后把另一个对象传入这个方法。

需要注意的是，所有对象都从 Object 类继承了 equals() 方法，但是默认的实现方式是使用 == 测试引用是否相同，而不是测试内容是否相同。想比较对象是否相等的类可以自定义 equals() 方法（这也是为什么定义类之后要重写这个类的 equals() 方法）。但是对于数组而言，由于始终继承默认的 equals() 方法，因此两个数组使用 equals() 方法和使用 == 方法的作用相等，因此比较数组是否相等可以使用 `java.util.Arrays.equals()` 实用方法。

# 自动装包和自动拆包

基本类型和引用类型的表现完全不同，有时候要把基本值当成对象，为此，Java平台为每一种基本类型都提供了包装类。Boolean、Byte、Short、Character、Integer、Long、Float、Double是不可变的最终类，每个实例只保存一个基本值。包装类一般在把基本值存储在集合中时使用。

Java支持装包和拆包类型转换。装包转换把一个基本值转换成对应的包装对象，而拆包转换的作用相反。虽然可以通过校正显式指定装包和拆包转换，但是没有必要这么做，因为把值赋值给变量或传入方法时会自动执行这种转换。此外，如果把包装对象给需要基本值的Java运算符或语句，也会自动执行拆包转换。因为Java能自动执行装包和拆包转换，所以这种语言特性一般叫做自动装包（autoboxing）。

自动装包也将集合处理变得更简单，例如使用Java的泛型限制列表和其他集合中能存储什么类型的值。
