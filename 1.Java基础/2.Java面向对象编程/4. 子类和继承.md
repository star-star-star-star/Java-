# 子类和继承的概念

通过定义子类或扩展超类向类中添加功能的能力，是面向对象编程范式的核心。

# 扩展类

使用 extends 关键字表明继承超类的字段和方法。例如：

```java
public class A extends B{
	//表明A类继承自B类
}
```

子类的另一个特性是：每个子类对象都是完全合法的超类对象，将子类对象赋值给超类的变量时无需校正，这种转换完全合法，超类变量中保存的值仍然是有效的子类对象，但编译器不确定这一点，因此不校正无法反向（缩小）转换。

如果声明类时使用了 final 修饰符，那么这个类无法被扩展或定义子类。

# 超类、对象、类的层次结构

用户自定义的每个类都有超类，如果没有使用 extends 子句指定超类，那么超类是 java.lang.Object 。Object是特殊的类，原因有如下两个：
1. Object类是Java中唯一一个没有超类的类；
2. 所有Java类都从Object类中继承方法。

因为每个类（除了Object类）都有超类，所以Java中的类组成一个类层次结构。这个体系可以使用一个根为Object类的树状图表示。

需要注意的是，Object类没有超类，而且其他每个类都只有一个超类。子类扩展的超类不能超过一个（单继承）。

# 子类的构造方法

可以在子类中使用 super() 调用超类的构造方法。super是Java的保留字，它的用法之一是，在子类的构造方法中调用超类的构造方法。这种用法和在一个构造方法中使用this()调用同一个类中的其他构造方法类似。

使用super()调用构造方法和使用this()调用构造方法有同样的限制：必须在构造方法的一个语句中调用超类的构造方法，甚至要放在局部变量声明之前。

传给super()的实参必须与超类构造方法的形参相匹配。如果超类定义了多个构造方法，那么super()可以调用其中任意一个，具体是哪一个，则由传入的参数决定。

# 构造方法链以及默认构造方法

创建类的实例时，Java保证一定会调用这个类的构造方法；创建任何子类的实例时，Java还保证一定会调用超类的构造方法。为了保证第二点，Java必须确保每个构造方法都会调用超类的构造方法。

因此，如果构造方法的第一个语句没有使用 this() 或 super() 显式调用另一个构造方法，javac编译器会插入 super() （即调用超类的构造方法，而且不传入参数）。如果超类没有无需参数的可见构造方法，这种隐式调用会导致编译出错。

构造方法链在一起调用，只要创建对象，就会调用一些列构造方法，从子类到超类，一直向上，直到类层次结构的顶端Object类为止。因为超类的构造方法始终在子类的构造方法的第一个语句中调用，所以Object类的构造方法的主体始终最先运行，然后运行Object类的子类的构造方法，就这样沿着类层次结构一直向下，直到实例化的那个类为止。

需要注意的是，调用构造方法时，超类中的字段也会被初始化。

如果构造方法没有调用超类的构造方法，Java会隐式调用。那么，如果类没有声明构造方法呢？此时，Java会为类隐式添加一个构造方法。这个默认的构造方法什么也不做，只是调用超类的构造方法。如果超类没有声明无参数的构造方法，那么在这个自动插入子类的默认构造方法中调用super()会导致编译出错。一般来说，如果类没有定义无参数的构造方法，那么它的所有子类必须显式调用超类构造方法的构造方法，而且要传入所需的参数。

如果类没有定义任何构造方法，默认会为其提供一个无参数的构造方法。声明为public的类，提供的构造方法也声明为public。提供给其他类的默认构造方法则不使用任何可见性修饰符，这些构造方法具有默认的可见性。

如果创建的public类不能公开实例化，就应该至少声明一个非public的构造方法，以此避免插入默认的public构造方法。从来不会实例化的类，应该定义一个private构造方法。这种构造方法不能在类外部调用，但可以避免自动插入默认的构造方法。

# 遮盖超类的字段

当子类中的字段和超类中的字段同名时，就意味着子类的某个字段遮盖了超类的某个字段。

需要注意的是，在你编写的代码中，为字段命名时应该避免遮盖超类的字段。如果遮盖了，几乎就表明代码写得不好。

有两种方法可以引用被遮盖的字段：
1. 单独使用字段名以及使用this关键字都表明引用的是子类的字段。使用super关键字表明引用的是超类的字段。
2. 把this或类的实例校正为适当的类，然后再访问字段 `((超类名) this).字段名` 。如果想引用的遮盖字段不是在类的直接超类中定义的，那么这种校正技术特别有用。

但是需要注意的是，不能使用 super.super.字段名 引用超类中的遮盖字段，这种句法是不合法的。

当然了，类字段也能被遮盖。引用被遮盖的类字段中的值，可以使用相同的super句法，但没有必要这么做，因为始终可以把类名放在类字段前引用这个字段。

# 覆盖超类的方法

如果类中定义的某个实例方法和超类的某个方法有相同的名称、返回值类型和参数，那么这个方法会覆盖（override）超类中对应的方法。在这个类的对象上调用这个方法时，调用的是新定义的方法，而不是超类中定义的旧方法。

需要注意的是，覆盖方法的返回值类型可以是原方法返回值的子类，没有必要一模一样，这叫做协变返回（covariant return）。

方法覆盖是面向对象编程中一项重要且有用的技术。下面针对方法覆盖的讨论只涉及实例方法，类方法的运作机制完全不同，无法覆盖。和字段一样，类方法也能被子类遮盖，但不能覆盖。好的编程风格是调用类方法时始终在前面加上定义这个方法的类名。如果把类名当作方法名的一部分，那么这两个方法的名称就不一样，因此其实并没有遮盖什么。

在进一步讨论方法覆盖之前，要理解方法覆盖和方法重载之间的区别。方法重载指的是在同一个类中定义多个名称相同但参数列表不同的方法。这和方法覆盖十分不同，因此不要混淆。

+ 覆盖不是遮盖

虽然Java使用很多类似的方式对待字段和方法，但方法覆盖和字段遮盖一点都不一样。为了引用遮盖的字段，只需要把对象校正成适当超类的实例，但不能使用这种技术调用覆盖的实例方法。

+ 虚拟方法查找

对于调用的是子类的方法还是超类的方法，事实上，源码编译器在编译时并不知道要调用哪个方法。不过，javac生成的字节码会在运行时使用“虚拟方法查找”（virtual method lookup）。解释器运行代码时，会检查变量引用的对象的真正运行时类型，然后找到适用于这个类型的方法。

需要注意的是，某些其他语言默认不使用虚拟方法查找，如果程序员想在子类中覆盖方法，要显式使用virtual关键字。

JVM不会直接使用关联在变量表示的静态类型身上的方法，如果这么做，前面详述的方法覆盖机制就不成立了。Java的实例方法默认使用虚拟查找。

+ 调用被覆盖的方法

调用被覆盖的方法的Java句法和访问被遮盖的字段的句法十分类似——都使用super关键字。解释器使用super句法调用实例方法时，会执行一种修改过的虚拟方法查找。第一步和常规的虚拟方法查找一样，确定调用方法的对象属于哪一个类。正常情况下，运行时会在这个类中寻找对应的方法定义。但是，使用super句法调用方法时，先在这个类的超类中查找。如果超类直接实现了这个方法，那就调用这个方法。如果超类继承了这个方法，那就调用继承的方法。

需要注意的是，super关键字调用的是方法的直接覆盖版本。

使用被覆盖的方法时，这种链式调用相当常见。覆盖方法是增强方法功能，但不完全取代这个方法的一种方式。

需要注意的是，不要将调用被覆盖方法的super和构造方法中调用超类构造方法的super()搞混了。虽然二者使用的关键字相同，但却是两种完全不同的句法。具体而言，可以在类中的任何位置使用super调用超类中被覆盖的方法，但是只能在构造方法的第一个语句中使用super()调用超类的构造方法。

还有一点很重要，只能在覆盖某个方法的类内部使用super调用被覆盖的方法。
