# 嵌套类型的概念

目前，所见到的类、接口和枚举类型都定义为顶层类型。也就是说，都是包的直接成员，独立于其他类型。不过，类型还可以嵌套在其他类型中定义，这种类型是“嵌套类型”（nested type），一般称为“内部类”，是Java语言的一个强大功能。

嵌套类型有两个独立的目的，但都和封装有关：
+ 如果某个类型需要特别深入地访问另一个类型的内部实现，可以嵌套定义这个类型。作为成员类型的嵌套类型，其访问方式于访问成员变量和方法的方式一样，而且能打破封装的规则。
+ 某个类型可能只在特定的情况下需要使用，而且只在非常小的代码区域使用。这个类型应该密封在一个小范围内，因为它其实是实现细节的一部分，应该封装在一个系统的其他部分无法接触到的地方。

嵌套类型也可以理解为通过某种方式和其他类型绑定在一起的类型，不作为完全独立的实体而真实存在。类型能通过四种不同的方式嵌套在其他类型中。
+ 静态成员类型。静态成员类型是定义为其他类型静态成员的类型。嵌套的接口、枚举和注解始终都是静态成员类型（就算它们不使用static关键字也是）。
+ 非静态成员类型。“非静态成员类型”就是没有使用static声明的成员类型。只有类才能作为非静态成员类型。
+ 局部类。局部类是在Java代码块中定义的类，只在这个块中可见。接口、枚举和注解不能定义为局部类型。
+ 匿名类。匿名类是一种局部类，但对Java语言来说，没有有意义的名称。接口、枚举和注解不能定义为匿名类型。

“嵌套类型”这个术语虽然正确且准确，但开发者并没有普遍使用，大多数Java程序员使用的是一个意义模糊的术语——“内部类”。根据语境的不同，这个术语可以指代非静态成员类、局部类或匿名类，但是不能指代静态成员类型，因此使用“内部类”这个术语时无法区分指代的是哪种嵌套类型。

虽然表示各种嵌套类型的术语并不总是那么明确，但幸运的是，从语境中一般都能确定应该使用哪种句法。

# 静态成员类型

静态成员类型和普通的顶层类型很像，但是为了方便，把它嵌套在另一个类型的命名空间中。

静态成员类型有如下的基本特征：
+ 静态成员类型类似于类的其他静态成员：静态字段和静态方法。
+ 静态成员类型和所在类的任何实例都不关联（即没有this对象）。
+ 静态成员类型只能访问所在类的静态成员。
+ 静态成员类型能访问所在类型中的所有静态成员（包括其他静态成员类型）。
+ 不管是否使用static关键字，嵌套的接口、枚举和注解都隐式声明为静态类型。
+ 接口或注解中的嵌套类型也都隐式声明为静态类型。
+ 静态成员类型可以在顶层类型中定义，也可以嵌入任何深度其他静态成员类型中。
+ 静态成员类型不能在其他嵌套类型中定义。

下面是一个例子：

```java
//使用链表实现堆栈的类
public class LinkedStack {
	//定义如何链接对象，其中的static关键字是可选的
	interface Linkable {
		public Linkable getNext();
		public void setNext(Linkable node);
	}
	//链表的头节点是一个Linkable对象
	Linkable head;

	public void push(Linkable node) {
	
	}
	public Object pop() {
	
	}
}

//这个类实现前面定义的静态成员接口
class LinkableInteger implements LinkedStack.Linkable {
	//节点的数据和构造方法
	int i;
	public LinkableInteger(int i) {
		this.i = i;
	}

	//实现接口所需的数据和方法
	LinkedStack.Linkable next;
	public LinkedStack.Linkable getNext() {
		return next;
	}
	public void setNext(LinkedStack.Linkable node) {
		next = node;
	}
}
```

静态成员类型能访问所在类型中的所有静态成员，包括私有成员。反过来也成立：所在类型的方法能访问静态成员类型中的所有成员，包括私有成员。静态类型甚至能访问任何其他静态成员类型中的所有成员，包括这些类型的私有成员。静态成员类型使用其他静态成员时，无需使用所在类型的名称限定成员的名称。

静态成员类型不能和任何一个外层类同名。而且，静态成员类型只能在顶层类型和其他静态成员类型中定义，也就是说，静态成员类型不能在任何成员类、局部类或匿名类中定义。

顶层类型可以声明为public或对包私有（即声明时不使用public关键字）。但是把顶层类型声明为private或protected都没什么意义——protected和对包私有其实是一样的，而任何其他类型都不能访问声明为private的顶层类。

然而，静态成员类型是一种成员，因此所在类型中的成员能使用的访问控制修饰符，静态成员类型都能使用。这些修饰符对静态成员类型来说，作用与用在类型的其他成员上一样。接口或注解的所有成员都隐式声明为public，所以嵌套在接口或注解类型中的静态成员类型不能声明为protected或private。

在所在类的外部，静态成员类型的名称由外层类型的名称和内层类型的名称组成。大多数情况下，这种句法有助于提醒内层类和所在的类型有内在联系。不过，Java语言允许使用import指令直接或间接导入静态成员类型。例如：

```java
//导入指定的嵌套类型
import pkg.LinkedStack.Linkable;
//导入LinkedStack中的所有嵌套类型
import pkg.LinkedStack.*;
```

导入后，引用嵌套类型时就不用包含外层类型的名称了。

还可以使用 `import static` 指令导入静态成员类型。但是，导入嵌套类型模糊了这个类型和外层类型之间的关系，而这种关系往往很重要，因此很少这么做。

# 非静态成员类型

非静态成员类声明为外层类或枚举类型的成员，而且不使用 `static` 关键字：
+ 如果把静态成员类型比作类字段或类方法，那么非静态成员类可以比作实例字段或实例方法；
+ 只有类才能作为非静态成员类型；
+ 一个非静态成员类的实例始终关联一个外层类型的实例；
+ 非静态成员类的代码能访问外层类型的所有字段和方法（静态和非静态的都能访问）；
+ 为了让非静态成员类访问外层实例，Java还提供了几个专用的句法。

下面是一个例子：

```java
//通过成员类实现的迭代器
import java.util.Iterator;

public class LinkedStack {
	//静态成员接口
	public interface Linkable {
		public Linkable getNext();
		public void setNext(Linkable node);
	}

	//链表的头结点
	private Linkable head;

	public void push(Linkable node) {}
	public Linkable pop() {}

	//该方法返回一个Iterator对象，供LinkedStack类使用
	public Iterator<Linkable> iterator() {
		return new LinkedIterator();
	}

	//实现Iterator接口，定义为一个非静态成员类
	protected class LinkedIterator implements Iterator<Linkable> {
		Linkable current;
		public LinkedIterator() {
			current = head;
		}
		public boolean hasNext() {
			return current != null;
		}
		public Linkable next() {
			if(current == null) {
				throw new java.util.NoSuchElementException();
			}
			Linkable value = current;
			current = current.getNext();
			return value;
		}
		public void remove() {
			throw new UnsupportedOperationException();
		}
	}
}
```

这边需要注意的是， `LinkedIterator` 类嵌套在 `LinkedStack` 类中。因为 `LinkedIterator` 是辅助类，只在 `LinkedStack` 类中使用，所以在离外层类很近的地方定义，能清晰地表达设计者的意图。

## 非静态成员类型的特性

与实例字段和实例方法一样，非静态成员类的每个实例都和外层类的一个实例关联。也就是说，成员类的代码能访问外层类实例的所有实例字段和实例方法（以及静态成员），包括声明为private的实例成员。

非静态成员类和类的任何成员一样，可以使用一个标准的访问控制修饰符。

## 非静态成员类型的限制

成员类有两个重要的限制：
+ 非静态成员类不能和任何外层类或包同名。这是一个重要的规则，但是不适用于字段和方法。
+ 非静态成员类不能包含任何静态字段、方法或类型，不过可以包含同时使用 static 和 final 声明的常量字段。

需要注意的是，静态成员是顶层结构，不和任何特定的对象关联，而非静态成员类和外层类的实例关联。在成员类中定义顶层静态成员会让人困惑，因此禁止这么做。

## 非静态成员类型的句法

成员类最重要的特性是可以访问外层对象的实例字段和方法。

如果想使用 this 显式引用，就要使用一种特殊的句法，显式引用 this 对象表示的外层实例。这种句法的一般形式是 `classname.this` ，其中 classname 是外层类的名称。注意，成员类中可以包含成员类，嵌套的层级不限。然而，因为成员类不能和任何外层类同名，所以，在 this 前面使用外层类的名称是引用任何外层实例最好的通用方式。但是，仅当引用的外层类成员被成员类的同名成员遮盖时才允许使用这种特殊的句法。

## 作用域和继承关系

顶层类可以扩展成员类，因此，对任何类来说，都必须考虑两种独立的层次结构：
1. 从超类到子类的继承层次结构，定义成员类继承的字段和方法。
2. 从外层类到内层类的包含层次结构，定义成员类作用域中的字段和方法（因此成员类可以访问这些字段和方法）。

需要熟悉这两种层次结构的特性和经验法则：
+ 这两种层次结构完全相互独立，一定不能混淆；
+ 避免命名冲突，即超类的字段或方法不能和外层类的字段或方法同名；
+ 如果出现了命名冲突，那么继承的字段或方法会取代外层类的同名字段或方法；
+ 继承的字段和方法作用域在继承它们的类中，会取代外层作用域中的同名字段和方法；
+ 为了避免混淆继承层次结构和包含层次结构，要注意包含层次结构不要太深；
+ 如果类嵌套超过两层，可能会导致更大的混乱；
+ 如果类的继承层次结构很深（即这个类有很多的祖先），可以考虑不把它定义为非静态成员类，而是定义为顶层类。

# 局部类

局部类在一个Java代码块中声明，不是类的成员。只有类才能局部定义，而接口、枚举类型和注解类型都必须是顶层类型或静态成员类型，不能被局部定义。局部类往往在方法中定义，但也可以在类的静态初始化程序或实例初始化程序中定义。

因为所有的Java代码块都在类中，所以局部类都嵌套在外层类中。因此，局部类和成员类有很多共同的特性。局部类往往更适合看成完全不同的嵌套类型。

局部类的典型特征是局部存在于一个代码块中。和局部变量一样，局部类只在定义它的块中有效。

下面是一个例子：

```java
//通过成员类实现的迭代器
import java.util.Iterator;

public class LinkedStack {
	//静态成员接口
	public interface Linkable {
		public Linkable getNext();
		public void setNext(Linkable node);
	}

	//链表的头结点
	private Linkable head;

	public void push(Linkable node) {}
	public Linkable pop() {}

	//该方法返回一个Iterator对象，供LinkedStack类使用
	public Iterator<Linkable> iterator() {
		//把LinkedIterator定义为局部类
		class LinkedIterator implements Iterator<Linkable> {
			Linkable current;
			public LinkedIterator() {
				current = head;
			}
			public boolean hasNext() {
				return current != null;
			}
			public Linkable next() {
				if(current == null) {
					throw new java.util.NoSuchElementException();
				}
				Linkable value = current;
				current = current.getNext();
				return value;
			}
			public void remove() {
				throw new UnsupportedOperationException();
			}
		}
		return new LinkedIterator();
	}

	
}
```

这样一来，把 LinkedIterator 类的定义移到了离使用它更近的位置，希望可以进一步提升代码的清晰度。

## 局部类的特性

局部类有如下两个特性：
1. 和成员类一样，局部类和外层实例相关，而且可以访问外层类的任何成员，包括私有成员。
2. 除了可以访问外层类定义的字段之外，局部类还能访问局部方法的作用域中声明为 final 的任何局部变量、方法参数和异常参数。

## 局部类的限制

局部类有如下的限制：
+ 局部类的名称只存在于定义它的块中，在块的外部不能使用。（但需要注意的是，在类的作用域中创建的局部类实例，在这个作用域之外仍然可以使用。）
+ 局部类不能声明为 public、protected、private或static。
+ 与成员类的原因一样，局部类不能包含静态字段、方法或类。唯一的例外是同时使用 static 和 final 声明的常量。
+ 接口、枚举类型和注解类型不能局部定义。
+ 局部类和成员类一样，不能与任何外层类同名。
+ 前面说过，局部类能使用同一个作用域中的局部变量、方法参数和异常参数，但这些变量或参数必须声明为 final 。这是因为，局部类实例的生命周期可能比定义它的方法的执行时间长很多。（局部类用到的每个局部变量都有一个私有内部副本，这些副本由javac自动生成。只有把局部变量声明为 final 才能保证局部变量和私有副本始终保持一致。）

## 局部类的作用域

局部类能访问继承自超类的任何成员以及外层类定义的任何成员，并且还能访问声明为 final 的局部变量和参数。

# 词法作用域和局部变量

局部变量在一个代码块中定义，这个代码块就是这个变量的作用域，在这个作用域之外无法访问这个局部变量，局部变量也不复存在。花括号划定块的边界，花括号中的任何代码都能使用这个块中定义的局部变量。这种作用域是“词法作用域”，定义变量能在哪一块源码中使用。程序员一般可以把这种作用域理解为暂时存在的事物，而不能认为局部变量的存在时间是从JVM开始执行代码块开始，到退出代码块为止。像这样理解局部变量和它的作用域一般是合理的。

但是，局部类的出现把这个局面搅乱了。注意，局部类的实例可能在JVM退出定义这个局部类的代码块后依然存在，这就是原因。也就是说，如果创建了局部类的一个实例，那么，JVM执行完定义这个类的代码块后，实例不会自动消失。因此，即便这个类在局部定义，但是这个类的实例能跳出定义它的地方。

这可能会导致一些效果，让某些初次接触的开发者惊讶。这是因为，局部类能使用局部变量，而且会从不复存在的词法作用域中创建变量值的副本。例如下面这段代码：

```java
public class Weird {  
    public static interface IntHolder {  
        public int getValue();  
    }  
    public static void main (String[] args) {  
        IntHolder[] holders = new IntHolder[10];  
        for(int i = 0; i < 10; i++) {  
            final int fi = i;  
            //局部类  
            class MyIntHolder implements IntHolder {  
                @Override  
                public int getValue() {  
                    return fi;  
                }  
            }  
            holders[i] = new MyIntHolder();  
        }  
        /*  
        * 局部类已经不在作用域中，因此此处不能使用局部类  
        * 但是在数组中保存的这10个有效实例中  
        * 虽然局部变量 fi 已经不在作用域中  
        * 但仍然在那10个对象的 getValue() 方法的作用域中  
        * 因此，可以使用每个对象的 getValue() 方法打印 fi 的值  
        * */       
        for(int i = 0; i < 10; i++) {  
            System.out.println(holders[i].getValue());  
        }  
    }  
}
```

为了理解这段代码，要记住一点，局部类中方法的词法作用域与解释器进出定义局部类的代码块没有任何联系。

局部类的各个实例用到的每个 final 局部变量，都会创建一个私有副本，因此，得到的效果是，创建实例时，这个实例拥有一个所在作用域的私有副本。

上面示例中的局部类 `MyIntHolder` 有时也叫做“闭包”（closure）。用更一般的Java术语来说，闭包是一个对象，它保存作用域的状态，并让这个作用域在后面可以继续使用。

在某些编程风格中，闭包是有用的。不同的编程语言使用不同的方式定义和实现闭包，Java通过局部类、匿名类和lambda表达式实现闭包。

# 匿名类

匿名类是没有名称的局部类，使用 new 运算符在一个简洁的表达式中定义和实例化。局部类是Java代码块中的一个语句，而匿名类是一个表达式，因此可以包含在大型表达式中，例如方法调用表达式。（但需要注意的是，在Java 8 之后，大多数情况下都把匿名类换成了lambda表达式。）

下面是一个例子，作用是使用匿名类实现的枚举功能：

```java
public Iterator<Linkable> iterator() {
	//匿名类在 return 语句中定义
	return new Iterator<Linkable>() {
		Linkable current;
		//将构造方法换成实例初始化程序
		{
			current = head;
		}
		//下面是三个由Iterator接口定义的方法
		public boolean hasNext() {
			return current != null;
		}
		public Linkable next() {
			if(current == null) {
				throw new java.util.NoSuchElementException();
			}
			Linkable value = current;
			current = current.getNext();
			return value;
		}
		public void remove() {
			throw new UnsupportedOperationException();
		}
	};//注意，这边要用分号结束return语句
}
```

可以看出，定义匿名类和创建这个类的实例使用new关键字，后面跟着某个类的名称以及放在花括号里的类主体。如果new关键字后面是一个类的名称，那么这个匿名类是指定类的子类。如果new关键字后面是一个接口的名称，那么这个匿名类实现指定的接口，并且扩展Object类。

需要注意的是，匿名类使用的句法无法指定 extends 子句和 implements 子句，也不能为这个类指定名称。

因为匿名类没有名称，所以不能在类主体中定义构造方法。这是匿名类的一个基本限制。定义匿名类时，在父类后面的括号中指定的参数，会隐式传给父类的构造方法。匿名类一般用于创建构造方法不接受任何参数的简单类的子类，所以，在匿名类的句法中，括号经常都是空的。

匿名类就是一种局部类，所以二者的使用限制一样。除了使用 static final 声明的常量之外，匿名类不能定义任何静态字段、方法和类。接口、枚举类型和注解类型不能匿名定义。而且，和局部类一样，匿名类不能声明为 public、private、protected或static。

定义匿名类的句法既定义了这个类也实例化了这个类。如果每次执行外层块时创建的实例不止一个，那么就不能用匿名类代替局部类。

因为匿名类没有名称，所以无法为匿名类定义构造方法。如果类需要构造方法，必须使用局部类。不过，经常可以使用实例初始化程序代替构造方法。（虽然实例初始化程序不仅限于在匿名类中使用，但就是为了这个目的才把这种功能引入Java语言的。匿名类不能定义构造方法，所以只有一个默认构造方法。使用实例初始化程序可以打破匿名类不能定义构造方法这个限制。）

# 嵌套类型的运作方式

引入嵌套类型后，Java虚拟机和Java类文件的格式并没有变化。对Java解释器而言，并没有所谓的嵌套类型，所有类都是普通的顶层类。为了让嵌套类型看起来是在另一个类中定义的，Java编译器会在它生成的类中插入隐藏字段、方法和构造方法参数。这些隐藏字段和方法经常称为“合成物”(synthetic)。

可以使用反汇编程序javap反汇编某些嵌套类型的类文件，了解为了支持嵌套类型，编译器用了什么技巧。

为了实现嵌套类型，javac把每个嵌套类型编译为单独的类文件，得到的其实是顶层类。编译得到的类文件使用特殊的命名约定，这些名称一般在用户的代码中无法创建。

因为嵌套类型编译成普通的顶层类，所以不能直接访问外层类型中有特定权限的成员。因此，如果静态成员类型使用了外层类型的私有成员（或者是具有其他权限的成员），编译器会生成合成的访问方法（具有默认的包访问权限），然后把访问私有成员的表达式转换成调用合成方法的表达式。

这四种嵌套类型的类文件使用如下命名约定：
+ （静态或非静态）成员类型。根据 EnclosingType$Member.class 格式命名成员类型的类文件。
+ 匿名类。因为匿名类没有名称，所以类文件的名称由细节决定。javac使用数字表示匿名类的名称（例如 EnclosingType$1.class）。
+ 局部类。局部类的类文件综合使用前面的两种命名方式（例如 EnclosingType$1Member.class）。

下面简单介绍一些实现细节，看一下javc如何为每种嵌套类型提供所需的合成访问能力。
+ 非静态成员类的实现。非静态成员类的每个实例都和一个外层类的实例关联。为了实现这种关联，编译器为每个成员类定义了一个名为 this$0 的合成字段。这个字段的作用是保存一个外层实例的引用。编译器为每个非静态成员类的构造方法提供了一个额外的参数，用于初始化这个字段。每次调用成员类的构造方法时，编译器都会自动把这个额外参数的值设定为外层类的引用。
+ 局部类和匿名类的实现。局部类之所以能访问外层类的字段和方法，原因和非静态成员类一模一样：编译器把一个外层类的隐藏引用传入局部类的构造方法，并且把这个引用存储在编译器合成的一个私有字段中。和非静态成员类一样，局部类也能使用外层类的私有字段和方法，因为编译器会插入任何所需的访问器方法。局部类和成员类的不同之处在于，局部类能访问所在块中的局部变量。不过这种能力有个重要的限制，即局部类只能访问声明为 final 的局部变量和参数。这个限制的原因从实现中可以清楚地看出来。局部类之所以能使用局部变量，是因为javac自动为局部类创建了私有实例字段，保存局部类用到的各个局部变量的副本。编译器还在局部类的构造方法中添加了隐藏的参数，初始化这些自动创建的私有字段。其实，局部类没有访问局部变量，真正访问的是局部变量的私有副本。如果在局部类外部能修改局部变量，就会导致不一致性。
